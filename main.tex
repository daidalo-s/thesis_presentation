\documentclass{beamer}
% --------------- PACCHETTI ---------------
% Immagini
\usepackage{graphicx} 
% Layout multicolonna
\usepackage{multicol}
% Listings
\usepackage{listings}    
% ------------- FINE PACCHETTI ---------------

\usetheme{Copenhagen}

% --------------- INTESTAZIONE ---------------
\title{Verifica funzionale di programmi con Dafny}
\author{Lorenzo Quellerba}
\institute{Univeristà degli Studi di Torino}
\date{June 2023}
% --------------- FINE INTESTAZIONE ---------------

\begin{document}
\maketitle
% Qua spieghi le caratteristiche del linguaggio:
% 1: Linguaggio oo con supporto anche funzionale (se lo vuoi dire)
% 2: Il processo di sviluppo in Dafny include anche la verifica funzionale 
% 3: Devi annotare programma con pre, post, inv, variant, e poi tutto a smt solver
% 4: Un programma Dafny poi può essere compilato in altri linguaggio di programmazione
\begin{frame}{Dafny}
    \only<1>{
        \begin{columns}[onlytextwidth]
            \column{0.7\textwidth}
                \begin{itemize}
                % Devo dire cosa distingue dafny dagli altri linguaggi di programazione:
                % il fatto che supporta nativamente la verifica funzionale
                % \item Dafny è un linguaggio di programmazione sviluppato da 
                % \textit{object oriented} che 
                % supporta sia il paradigma imperativo che quello funzionale
                % \item Supporta la specifica formale attraverso precondizioni, 
                % postcondizioni, invarianti, varianti e i \textit{dynamic frames} per 
                % la formalizzazione delle modifiche della memoria
                % \item La correttezza del codice viene verificata rispetto alla specifica 
                % data da un SMT solver (\textit{correct by construction})
                % \item Al termine del processo di verifica un programma Dafny può essere 
                % compilato in altri linguaggi tra cui C++, Go, Java
                    % \item Dafny è un linguaggio di programmazione che include al suo interno 
                    % meccanismi dedicati alla verifica di correttezza funzionale 
                    % del programma
                    % \item Il linguaggio comprende imperative, sequential, supports generic 
                    % classes, inheritance and abstraction, methods and functions, dynamic 
                    % allocation, inductive and coinductive datatypes, and specification 
                    % constructs
                    % \item To further support specifications, the language also offers 
                    % updatable ghost variables, recursive functions, and types like sets 
                    % and sequences. Specifications and ghost constructs are used only during 
                    % verification; the compiler omits them from the executable code.
                    \item Dafny è un linguaggio di programmazione che supporta nativamente la verifica funzionale
                    \item Durante lo sviluppo, un programma Dafny viene annotato con la specifica del comportamento 
                    e automaticamente un verificatore statico controlla che il codice rispetti la specifica (correct by construction)
                    \item Il linguaggio supporta (caratteristiche ad alto livello)
                \end{itemize}
            \column{0.25\textwidth}
            \begin{figure}
                \includegraphics[scale=0.4]{./assets/images/dafny-logo-230.png}
            \end{figure}
        \end{columns}
}
    \only<2>{
        \begin{itemize}
            \item La formalizzazione della specifica è resa possibile da precondizioni, 
            postcondizioni, invarianti, metriche di terminazione e il framing della 
            memoria nel caso di side effects
            \item Il verificatore statico esegue continuamente la verifica in background grazie ad un LSP e riporta gli errori: per l’utente 
            l’interazione è la medesima che si avrebbe com un compilatore
            \begin{figure}
                \includegraphics[scale=0.35]{./assets/images/error_example.png}
            \end{figure}
            \item Il programma finale può essere compilato in altri linguaggi (elenco) per permette integreazione in altri programmi
        \end{itemize}    
    }
\end{frame}

\begin{frame}{Dafny: funzionamento}
    % Ora un veloce richiamo di teoria 
    % 1. Concetto alla base è quello di tripla di Hoare
    % 2. Per separare parte logica da parte sintattica usi wp calculus
    % 3. La formula che ottieni viene passata a SMT solver
    % 4. Grafico smt solver
    \only<1>{
    \begin{block}{Tripla di Hoare}
        \begin{center}
            \{P\}C\{Q\}     
        \end{center}
        Se l'asserzione \textit{P} è vera prima dell'esecuzione del comando \textit{C} allora l'asserzione \textit{Q} sarà vera al termine dell'esecuzione
    \end{block}
    \begin{block}{\textit{Predicate transformer semantics}}
        La semantica dei \textit{predicate transformer} è una riformulazione della logica di \textit{Floyd-Hoare} che definisce una strategia completa per la costruzione di deduzioni valide
    \end{block}
    \begin{block}{\textit{Weakest precondition}}
        Dato un comando \textit{C} e una postcondizione \textit{Q} la \textit{weakest precondition} (\textit{wp}) è un predicato \textit{$\phi$} tale per cui per ogni precondizione \textit{P}, \{P\}C\{Q\} se e solo se P$\implies \phi$
    \end{block}
    }
    \only<2>{
        \begin{figure}
            \includegraphics[scale=0.4]{./assets/images/mechanism.png}
        \end{figure}
    }
\end{frame}

\begin{frame}{Caratteristiche del linguaggio}
% Ora veramente in super sintesi le caratteristiche del linguaggio
% 1. Tipi
% 2. Generici
% 3. Predicati metodi e funzioni    
    \begin{itemize}
        \item Reference types e value types
        \item Generici
        \item predicati metodi funzioni classi
        \item 
    \end{itemize}
\end{frame}

\begin{frame}{Albero binario di ricerca}
% Albero binario di ricerca con veloce presentazione della struttura dati
    Richiamo di teoria della struttura
\end{frame}

\begin{frame}{BST: variabili d'istanza}
    \lstinputlisting[]{./assets/code/bst_instance_var.dfy}
\end{frame}

\begin{frame}{BST: invariante di struttura}
    \lstinputlisting[]{./assets/code/bst_invariant.dfy}
\end{frame}

\begin{frame}{BST: costruttore}
    \lstinputlisting[]{./assets/code/bst_constructor.dfy}
\end{frame}

\begin{frame}{BST: inserimento}
    \lstinputlisting[]{./assets/code/bst_insert.dfy}
\end{frame}

\begin{frame}{BST: ricerca}
    \lstinputlisting[]{./assets/code/bst_find.dfy}
\end{frame}

\begin{frame}{BST: cancellazione}
    \only<1>{
        \lstinputlisting[]{./assets/code/bst_remove.dfy}
    }
    \only<2>{
        \lstinputlisting[]{./assets/code/bst_removeMin.dfy}
    }
\end{frame}

\end{document}
